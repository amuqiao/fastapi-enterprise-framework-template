# 9.2 容器运行最佳实践

## 9.2.1 核心原则

### 9.2.1.1 单一职责原则

每个容器应该只运行一个主要进程，这是容器设计的核心原则之一。单一职责原则可以带来以下好处：

- **更简单的管理**：每个容器只负责一个功能，便于管理和监控
- **更高的可靠性**：一个进程失败不会影响其他进程
- **更快的部署**：容器更小，部署速度更快
- **更好的可扩展性**：可以独立扩展每个容器
- **更容易的调试**：问题定位更简单

### 9.2.1.2 无状态原则

容器应该是无状态的，所有状态数据应该存储在外部存储系统中，如数据库、缓存或分布式文件系统。无状态设计可以带来以下好处：

- **更容易的扩展**：可以快速创建多个相同的容器实例
- **更高的可用性**：容器故障不会导致数据丢失
- **更简单的部署**：可以随时替换容器，不需要考虑状态迁移
- **更好的弹性**：可以快速适应流量变化

### 9.2.1.3 不可变性原则

容器应该是不可变的，一旦创建就不应该修改。如果需要更新容器，应该创建一个新的容器并替换旧的容器。不可变性原则可以带来以下好处：

- **更可靠的部署**：每次部署都是全新的容器，避免了累积错误
- **更容易的回滚**：可以快速回滚到之前的版本
- **更好的一致性**：所有容器实例都是相同的
- **更高的安全性**：避免了容器运行时被修改的风险

## 9.2.2 容器运行配置

### 9.2.2.1 资源限制

为容器配置合理的资源限制，避免单个容器消耗过多资源：

```bash
# 限制CPU和内存
docker run -d --name app \
  --cpus 1 \
  --memory 512m \
  --memory-swap 1g \
  myapp:1.0

# 限制CPU份额（相对权重）
docker run -d --name app \
  --cpu-shares 512 \
  myapp:1.0

# 限制块IO
docker run -d --name app \
  --blkio-weight 500 \
  myapp:1.0

# 限制网络带宽
docker run -d --name app \
  --network my-network \
  --cap-add NET_ADMIN \
  myapp:1.0
```

### 9.2.2.2 重启策略

配置合理的重启策略，确保容器在故障时能够自动恢复：

```bash
# 不自动重启（默认）
docker run -d --name app --restart no myapp:1.0

# 总是重启
docker run -d --name app --restart always myapp:1.0

# 失败时重启，最多重试5次
docker run -d --name app --restart on-failure:5 myapp:1.0

# 除非手动停止，否则总是重启
docker run -d --name app --restart unless-stopped myapp:1.0
```

### 9.2.2.3 健康检查

配置健康检查，确保容器正常运行：

```bash
# 运行时配置健康检查
docker run -d --name app \
  --health-cmd="curl -f http://localhost:8080/health || exit 1" \
  --health-interval=30s \
  --health-timeout=10s \
  --health-start-period=5s \
  --health-retries=3 \
  myapp:1.0
```

### 9.2.2.4 日志配置

配置合理的日志驱动和日志选项：

```bash
# 使用json-file日志驱动，并限制日志大小
docker run -d --name app \
  --log-driver json-file \
  --log-opt max-size=10m \
  --log-opt max-file=3 \
  myapp:1.0

# 使用syslog日志驱动
docker run -d --name app \
  --log-driver syslog \
  --log-opt syslog-address=udp://syslog-server:514 \
  myapp:1.0

# 使用fluentd日志驱动
docker run -d --name app \
  --log-driver fluentd \
  --log-opt fluentd-address=localhost:24224 \
  myapp:1.0
```

## 9.2.3 容器网络配置

### 9.2.3.1 使用自定义网络

优先使用自定义网络，而不是默认的bridge网络：

```bash
# 创建自定义bridge网络
docker network create my-network

# 使用自定义网络运行容器
docker run -d --name app --network my-network myapp:1.0

# 连接现有容器到自定义网络
docker network connect my-network existing-container
```

### 9.2.3.2 网络隔离

使用不同的网络隔离不同的服务，提高安全性：

```bash
# 创建前端网络
docker network create frontend-network

# 创建后端网络
docker network create backend-network

# 运行前端容器，连接到前端网络
docker run -d --name frontend --network frontend-network nginx:alpine

# 运行后端容器，连接到前端和后端网络
docker run -d --name backend --network frontend-network --network backend-network myapp:1.0

# 运行数据库容器，只连接到后端网络
docker run -d --name db --network backend-network mysql:8.0
```

### 9.2.3.3 端口映射

最小化端口映射，只映射必要的端口：

```bash
# 不推荐：映射所有端口
docker run -d --name app -P myapp:1.0

# 推荐：只映射必要的端口
docker run -d --name app -p 80:80 myapp:1.0

# 使用随机端口映射
docker run -d --name app -p 80 myapp:1.0
```

## 9.2.4 数据管理

### 9.2.4.1 使用命名卷

优先使用命名卷，而不是绑定挂载：

```bash
# 使用命名卷
docker run -d --name db -v mysql-data:/var/lib/mysql mysql:8.0

# 使用绑定挂载
docker run -d --name db -v ./mysql-data:/var/lib/mysql mysql:8.0
```

### 9.2.4.2 数据卷备份

定期备份数据卷，防止数据丢失：

```bash
# 备份数据卷
docker run --rm -v mysql-data:/volume -v $(pwd):/backup ubuntu tar -czvf /backup/mysql-data.tar.gz /volume

# 恢复数据卷
docker volume create mysql-data
docker run --rm -v mysql-data:/volume -v $(pwd):/backup ubuntu tar -xzvf /backup/mysql-data.tar.gz -C /
```

### 9.2.4.3 数据卷权限

确保数据卷的权限配置正确：

```bash
# 运行时指定用户
docker run -d --name app -v app-data:/app/data -u 1000:1000 myapp:1.0

# 在Dockerfile中设置用户
FROM alpine:3.16
RUN adduser -D -u 1000 appuser
USER appuser
WORKDIR /app
VOLUME /app/data
CMD ["app"]
```

## 9.2.5 容器监控与日志

### 9.2.5.1 实时监控

使用Docker Stats命令实时监控容器资源使用情况：

```bash
# 查看所有容器的资源使用情况
docker stats

# 查看特定容器的资源使用情况
docker stats app

# 不实时刷新，只显示一次
docker stats --no-stream
```

### 9.2.5.2 日志管理

集中管理容器日志，便于分析和排查问题：

```bash
# 查看容器日志
docker logs app

# 实时查看日志
docker logs -f app

# 查看最近100行日志
docker logs --tail 100 app

# 查看带时间戳的日志
docker logs -t app

# 过滤日志
docker logs app | grep "error"
```

### 9.2.5.3 健康检查监控

监控容器的健康状态：

```bash
# 查看容器健康状态
docker inspect --format='{{json .State.Health}}' app | jq

# 过滤健康状态为unhealthy的容器
docker ps -f health=unhealthy
```

## 9.2.6 容器生命周期管理

### 9.2.6.1 启动顺序

确保容器按照正确的顺序启动，处理服务依赖关系：

```bash
# 使用docker-compose的depends_on
services:
  web:
    depends_on:
      db:
        condition: service_healthy
  
  db:
    image: mysql:8.0
    healthcheck:
      test: ["CMD", "mysqladmin", "ping", "-h", "localhost"]
      interval: 10s
      timeout: 5s
      retries: 5
```

### 9.2.6.2 优雅关闭

确保容器能够优雅关闭，处理未完成的请求：

```dockerfile
# 在Dockerfile中配置STOPSIGNAL
FROM alpine:3.16
STOPSIGNAL SIGTERM
CMD ["app"]

# 运行容器时配置停止超时
docker run -d --name app --stop-timeout 30 myapp:1.0
```

### 9.2.6.3 容器更新

使用滚动更新策略，确保服务不中断：

```bash
# 使用docker-compose更新服务
docker-compose up -d --no-deps --build web

# 使用Docker Swarm的滚动更新
docker service update --replicas 3 --update-parallelism 1 --update-delay 10s myapp
```

## 9.2.7 容器安全运行

### 9.2.7.1 非root用户运行

避免使用root用户运行容器：

```bash
# 运行时指定用户
docker run -d --name app -u 1000:1000 myapp:1.0

# 在Dockerfile中创建并使用非root用户
FROM alpine:3.16
RUN adduser -D -u 1000 appuser
USER appuser
CMD ["app"]
```

### 9.2.7.2 最小权限原则

只授予容器必要的权限，避免使用特权模式：

```bash
# 不使用特权模式
docker run -d --name app myapp:1.0

# 只授予必要的能力
docker run -d --name app --cap-drop ALL --cap-add NET_BIND_SERVICE myapp:1.0

# 使用只读文件系统
docker run -d --name app --read-only myapp:1.0
```

### 9.2.7.3 避免敏感信息

不要在容器中存储敏感信息，使用环境变量或外部密钥管理服务：

```bash
# 使用环境变量传递敏感信息
docker run -d --name app \
  -e DB_PASSWORD=123456 \
  myapp:1.0

# 使用Docker Secrets（Swarm模式）
docker secret create db-password ./password.txt
docker service create --name app --secret db-password myapp:1.0

# 使用外部密钥管理服务，如HashiCorp Vault
```

## 9.2.8 容器运行最佳实践总结

1. **遵循单一职责原则**：每个容器只运行一个主要进程
2. **设计无状态容器**：所有状态数据存储在外部存储系统
3. **采用不可变性设计**：更新时创建新容器，不修改现有容器
4. **配置合理的资源限制**：避免单个容器消耗过多资源
5. **使用自定义网络**：提高网络隔离性和安全性
6. **优先使用命名卷**：便于管理和备份
7. **配置健康检查**：确保容器正常运行
8. **集中管理日志**：便于分析和排查问题
9. **使用非root用户**：提高容器安全性
10. **最小权限原则**：只授予必要的权限
11. **避免敏感信息**：使用环境变量或外部密钥管理服务
12. **优雅关闭容器**：处理未完成的请求
13. **滚动更新**：确保服务不中断
14. **监控容器健康状态**：及时发现问题
15. **定期备份数据**：防止数据丢失

通过遵循这些最佳实践，可以确保容器的稳定运行、高效管理和安全可靠。